#pragma config(Sensor, S1,     distance,       sensorSONAR)
#pragma config(Sensor, S2,     lightA,         sensorLightActive)
#pragma config(Sensor, S3,     lightB,         sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "wait.h";

/**
 * Line follower proporzionale (con margine di errore) utilizzando i metodi della libreria wait.
 *
 * @author Bryan Beffa
 * @author Matteo Forni
 * @version 11.01.2019
 */

int setWhite()
{
	int white;
	while(true)
  {
  	//stampo sul display
  	nxtDisplayCenteredTextLine(1, "Premi la freccia");
  	nxtDisplayCenteredTextLine(2, "destra per");
  	nxtDisplayCenteredTextLine(3, "selezionare");
  	nxtDisplayCenteredTextLine(4, "il colore bianco");

  	//premere il tasto destro per selezionare il colore bianco
    if (nNxtButtonPressed == 1)
    {
      white = (SensorValue[lightA]+SensorValue[lightB])/2;
      writeDebugStreamLine("bianco: %d", white);
      return white;
    }
	}
}

int setBlack()
{
	int black;
	while (true)
  {
  	//stampo sul display
  	nxtDisplayCenteredTextLine(1, "Premi la freccia");
  	nxtDisplayCenteredTextLine(2, "sinistra per");
  	nxtDisplayCenteredTextLine(3, "selezionare");
  	nxtDisplayCenteredTextLine(4, "il colore nero");

  	//premere il tasto sinistra per selezionare il colore nero
    if (nNxtButtonPressed == 2)
    {
      black = (SensorValue[lightA]+SensorValue[lightB])/2;
      return black;
    }
	}
}

task main()
{
	int white;
	int black;

	//setto il bianco e il nero
	white = setWhite();
	black = setBlack();


	bool startProgram = true;
	while(startProgram)
	{
		//stampo sul display
  	nxtDisplayCenteredTextLine(1, "Premi il bottone");
  	nxtDisplayCenteredTextLine(2, "centrale per");
  	nxtDisplayCenteredTextLine(3, "iniziare il ");
  	nxtDisplayCenteredTextLine(4, "line follower");

		//premere il tasto al centro per iniziare il line follower
    if (nNxtButtonPressed == 3)
    {
    	eraseDisplay();
    	break;
    }
	}

	while(waitDistance(distance, 20)){
		//margine consentito
		double margin = 1.5;

		//soglia di luce riflessa
		int threshold = 50;

		//calcolo l'errore
		int errorA = SensorValue[lightA] - (white+black)/2;
		int errorB = SensorValue[lightB] - (white+black)/2;

		//calcolo la velocità
		double speedA = errorA * margin;
		double speedB = errorB * margin;

		//setto la velocità al motore collegato alla porta A e alla porta B
		motor[motorB] = speedB+15;
		motor[motorA] = speedA+15;
		waitTime(10);
	}

	motor[motorB] = 0;
	motor[motorA] = 0;

	//muovo il motore secondario
	waitDegrees(motorC, 160, -20);
}
